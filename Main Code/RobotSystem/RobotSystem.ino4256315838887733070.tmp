// --------- Library Imports ---------                           // --------- Library Imports ---------
#include <Adafruit_MotorShield.h>                                // Import motor shield library
#include <Servo.h>                                               // Import servo library


// --------- Important Variables ---------                       // --------- Important Variables ---------
int robot_test_state = 25;                                       // Variable to control if the robot runs a test or not. 0 = Normal, 1 = Test 1, 2 = Test 2 etc. See tests.txt for details
int robot_state = 0;                                             // Variable to track the stage of the problem (0=start,1=got 1 dummy,2=dropped off one dummy)
int robot_sub_state = 0;
unsigned long tick_counter = 0;                                  // Counts the number of ticks elapsed since program started running
unsigned const int tick_length = 20;                             // The length of one tick in milliseconds. Clock Frequency = 1/tick_length. Since IR sensor takes ~12ms, 20ms currently used
bool program_started = false;                                    // Bool to store if the program start button has been pressed yet or not
bool using_servos = false;                                       // Bool to track if we are using the servos
bool main_test_started = false;
int stopping_distance = 8;                                       // Distance to stop away from dummies before grabbing (in cm)

// --------- Hardware Constants ---------                        // --------- Hardware Constants ---------
const int LM_port =  3;                                          // Motor shield port that the left motor uses
const int RM_port = 4;                                           // Motor shield port that the right motor uses
const int LED1_PIN = 0;                                          // Pin used for Orange LED (LED1)
const int LED2_PIN = 1;                                          // Pin used for Red LED (LED2)
const int LED3_PIN = 2;                                          // Pin used for Green LED (LED2)
const int LS1_PIN = A0;                                          // Pins used for Line Sensors (LS) 1, 2 and 3
const int LS2_PIN = A2;
const int LS3_PIN = A1;
const int TRIG_PIN = 13;                                         // TRIG and ECHO pins are used for the ultrasonic sensor
const int ECHO_PIN = 12;
const int IR_AMP_PIN = A3;                                       // Pin used to read the amplitude of the IR signal
const int IR_MOD_PIN = 5;                                        // IR to detect modulation and hence identify dummeis
const int SERVO_1_PIN = 9;                                       // Claw grab servo
const int SERVO_2_PIN = 8;                                       // Claw lift servo
const int BUTTON_PIN = 11;                                       // Pin for button to start the program (not stop if pressed again!)

// --------- Sensor Variables ---------                          // --------- Sensor Variables ---------
bool line_1, line_2, line_3;                                     // Booleans to describe if each line sensor has a line below or not
int IR_amplitude;                                                // Output magnitude of IR sensor (for locating dummies)
int max_IR_amplitude;                                            // Maximum value of IR recorded throughout a rotation
int US_amplitude;                                                // Distance recorded by the ultrasonic sensor in cm. Return 200 if out of range (dist > 200cm)


// --------- Logic Variables ---------                           // --------- Logic Variables ---------
bool horizontal_line = false;
bool finished_dropping = false;
bool picked_up_yet = false;
bool turned_yet = false;
bool are_we_pointing_at_dummy = false;
int what_dummy_am_I;                                             // The dummy that is detected (0 for line, 1 for red box, 2 for blue box)
bool dummy_located = false;                                      // If a dummy has been spotted using IR amplitude or not
int number_dummies_saved =0;
int hit_cross_roads =0;                                          // used in test state 6 (first competition) to detect when hit cross roads and ignore it and carry on

int proximity_counter = 0;
int proximity_counter_2 = 0;
int counter_cutoff = 3;

bool currently_adjusting = false;                                // Bool used by home_dummy() to track when the robot is currently doing an adjustment sweep
bool finished_adjusting = false;

// --------- Timer/Timing Variables ---------                    // --------- Timer/Timing Variables ---------
unsigned long delay_5s_start_time = 0;
unsigned long reverse_3s = 0;
unsigned long reverse_touch = 0;
unsigned long drive_1s_timer = 0;
unsigned long drive_1s_2 = 0;
unsigned long sweep_start_time = 0;                              // Timer used to time how long to sweep when searching for a dummy with IR amplitude sensor

unsigned long home_sweep_time = 0;                               // Timer used to drive forwards for a fixed amount of time before each adjustment in home_dummy()
unsigned long creep_time = 3000;                                 // Time that home_dummy() waits between each adjustment

unsigned long turn_timer = 0;                                    // Timer used for turning 360, 180 or 90 degrees

const int full_360_time = 9330.0;                                // Time taken for full 360 at set motor speed
const int motor_360_speed = 255;                                 // Motor speed used for turning a full 360

unsigned long pick_up_dummy_start_time = 0;                      // Time to start picking up dummy
unsigned long drop_off_dummy_start_time = 0;                     // Time to start dropping off dummy

int proximity_counter2 = 0;

bool temp_test_var1 = false;
int temp_test_var2 = 0;
bool temp_test_var3 = false;
bool temp_test_var4 = false;
bool temp_test_var5 = false;
int temp_test_var6 = 0;
int temp_test_var7 = 0;


// --------- Motor Initialisation ---------                      // --------- Motor Initialisation ---------
Adafruit_MotorShield AFMS = Adafruit_MotorShield();              // Create motorshield object called 'AFMS' with default I2C address. Put I2C address in brackets if different address needed
Adafruit_DCMotor *left_motor = AFMS.getMotor(LM_port);           // Initialise left  motor using assigned motor shield port
Adafruit_DCMotor *right_motor = AFMS.getMotor(RM_port);          // Initialise right motor using assigned motor shield port

Servo claw_servo;                                                // Servo for grabbing dummy
Servo lift_servo;                                                // Servo for lifting claw


// --------- Electrical Functions ---------                      // --------- Electrical Functions ---------
void drive_motor(Adafruit_DCMotor* motor, int spd, bool rev) {   // Electrical function that drives a single motor. motor: 0=Left,1=Right; spd: 0-255; rev: bool, true = Reverse
  
  if (rev) {                                                     // If motor needs to run in reverse
    motor->run(BACKWARD);                                        // Run in reverse
    }
  else {
    motor->run(FORWARD);                                         // Run forwards
  }
  motor->setSpeed(spd);                                          // Set motor speed to spd inputted

  if (spd != 0) {                                                // If motor running at non-zero speed
    if (tick_counter*tick_length % 500 < 250) {                  // Use tick_counter*tick_length to set 500ms frequency for LED flashing
      digitalWrite(LED1_PIN,HIGH);                                 // Write HIGH output to LED Pin 1 (orange LED)
    }
    else if (tick_counter*tick_length % 500 > 249) {             // If in second half of 500ms time period (since 50% duty cycle)
      digitalWrite(LED1_PIN,LOW);                                // Write LOW output to LED Pin 1 (orange LED)
    }
  }
  else {
    digitalWrite(LED1_PIN,LOW);                                  // Turn orange LED off if not moving (writing spd = 0)
  } 
}

                                                                 // Function to record voltage amplitude of IR sensor 10% duty cycle signal
                                                                 // IR_PIN must be an analog pin for any non-binary results.
                                                                 // Wave is ~6ms long, and samples take ~ 112us, so set samples to AT LEAST >54 to ensure peak is included in measurement (preferably > 108)
int measure_IR_amplitude(int samples = 107) {                    // CODE IS BLOCKING TO ALLOW FAST SAMPLING RATE - blocking time will increase linearly with samples
  
  int max_val = 0;                                               // Variable to store max. voltage measured
  int new_val;                                                   // Variable to store current measurement
  for (int i=0; i<samples; i++) {
    new_val = analogRead(IR_AMP_PIN);                            // Measure current voltage from photodiode
    if (new_val > max_val) {
      max_val = new_val;                                         // Update maximum recorded value if it is new highest
    }
  }
  return max_val;
}

int take_ultrasonic_reading() {                                  // Function to return the distance (in cm) measured by the ultrasonic sensor
  
  long duration, distance;                                       
  digitalWrite(TRIG_PIN, LOW);                                   // TRIG pin sends a pulse out...
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH); 
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW); 
  duration = pulseIn(ECHO_PIN, HIGH);                            // ...and the ECHO pin records the reflected pulse and measures the time to find the distance
  
  distance = (duration/2) / 29.1; 
  
  if (distance >= 200 || distance <= 0){                         // If distance more than 200, just return 200 (max output)
    return 200;
  } 
  else { 
    return distance;                                             // If between 0 and 200, return the actual value
  } 
}

void read_line_sensors() {                                       // Update the booleans line_N with whether they are on the line or not (cutoff = 500)

  if (analogRead(LS1_PIN) < 150) {                               // Checks if we meet the cutoff or not (less than 500 = White)
    line_1 = true;
  }
  else {
    line_1 = false;
  }
  if (analogRead(LS2_PIN) < 800) {
    line_2 = true;
  }
  else {
    line_2 = false;
  }
  if (analogRead(LS3_PIN) < 750) {
    line_3 = true;
  }
  else {
    line_3 = false;
  }
}


// --------- Software Functions ---------                        // --------- Software Functions ---------
bool follow_line() {                                             // Function that drives the motors and uses line sensors to move allow the line. Doesn't take inputs to stop (only call this function if the path is clear) ouput true when hits horizontal line
  
  read_line_sensors();                                           // Update line sensor booleans
  
  if ((line_2) and (not line_1) and (not line_3)){               // Default on the line, go straight ahead case
    drive_motor(left_motor, 255, false);
    drive_motor(right_motor, 255, false);
  }
  else if ((not line_2) and (not line_1) and (not line_3)){      // Central detector off line but niether side on line yet but carry on straight (this shouldn't happen normally)
    drive_motor(left_motor, 255, false);
    drive_motor(right_motor, 255, false);
  }                                                              
  else if ((line_1) and (not line_3)){                           // Hit line on LHS  so steering RIGHT
    drive_motor(left_motor, 255, false);
    drive_motor(right_motor, 200, false);
  }                                                              
  else if ((not line_1) and (line_3)){                           // Hit line on RHS  so steering LEFT
    drive_motor(left_motor, 200, false);
    drive_motor(right_motor, 255, false);
  }                                                              
  else if ((line_2) and (line_1) and (line_3)){                  // Hit horizontal line (return TRUE)
    drive_motor(left_motor, 255, false);
    drive_motor(right_motor, 255, false);
    return true;
  }
  else{                                                          // Some funky angles going on here, not an ideal case just sorta spin a'c'wise I guess
    drive_motor(right_motor, 255, false);
    drive_motor(left_motor, 255, true);
  }
  return false;
}

                                                                 // Function to: Stop, spin on the spot, turn towards brighest dummy seen, stop again and set dummy_located = true
bool point_towards_nearest_dummy(int sweep_time = full_360_time, float threshold = 0.7, int motor_sweep_speed = 255) {

  if (sweep_start_time == 0 and not dummy_located) {             // If haven't started sweeping yet (first time activating function) and haven't already found dummy
    sweep_start_time = tick_counter*tick_length;                 // Set start time to current time
    max_IR_amplitude = 0;                                        // Initialise IR amplitude at 0
    drive_motor(left_motor, 0, false);                           // Stop driving to prepare for turning around
    drive_motor(right_motor, 0, false);
  }

  if (tick_counter*tick_length < sweep_start_time+sweep_time) {  // If still within first sweep (sweep_start_time -> sweep_start_time + sweep_time)
    
    drive_motor(left_motor, motor_sweep_speed, true);            // Drive left in reverse, right forwards to turn counter-clockwise (turn slowly)
    drive_motor(right_motor, motor_sweep_speed, false);
  
    IR_amplitude = measure_IR_amplitude(107);                    // Take IR sensor input
  
    if (IR_amplitude > max_IR_amplitude) {                       // If new max found...
      max_IR_amplitude = IR_amplitude;                           // ...set max to current value
    }
  }                                                              // If outside of first sweep and within second. The second sweep lasts no more than 3x as long as the first sweep
  else if (tick_counter*tick_length < sweep_start_time + 4*sweep_time) {

    if (not dummy_located) {                                     // If haven't found dummy yet

      IR_amplitude = measure_IR_amplitude(107);                  // Read IR amplitude

      if (IR_amplitude < max_IR_amplitude*threshold) {           // If IR value hasn't reached cutoff (threshold*max_IR_amplitude), then continue turning, searching

        drive_motor(left_motor, motor_sweep_speed, false);       // Drive left in reverse, right forwards to turn counter-clockwise (turn slowly)
        drive_motor(right_motor, motor_sweep_speed, true);
        
      }
      else {                                                     // If reached cutoff (threshold*max_IR_amplitude), then declare dummy found and stop turning, reset sweep_start_time
        dummy_located = true;                                    // Dummy found
        sweep_start_time = 0;                                    // Reset sweep start time
        drive_motor(left_motor, 0, false);                       // Stop driving
        drive_motor(right_motor, 0, false);                      // Stop driving
        return true;
        
      }
    }                                                            // If outside 2nd sweep and no dummy found, just stop (and have a little cry)
    else if (tick_counter*tick_length > sweep_start_time + 4*sweep_time){
      drive_motor(left_motor, 0, false);                         // Stop driving
      drive_motor(right_motor, 0, false);                        // Stop driving
    }
  }
  return false;
}

//bool home_dummy() {                                              // Algorithm to drive forwards and adjust so perfectly* in front of dummy
//
//  US_amplitude = take_ultrasonic_reading();                      // Update ultrasonic distance reading
//
//  if (US_amplitude > home_adjust_distance) {                     // If too far away to bother adjusting...
//    drive_motor(left_motor, 200, false);                         // ...just drive
//    drive_motor(right_motor, 200, false);
//  }
//  else {
//    if (adjust_start_time == 0) {                                // If within adjust distance, activate this once:
//      adjust_start_time = tick_counter*tick_length;              // Set start time to current time
//      dummy_located = false;                                     // Declare that dummy not found
//    }
//    else if (tick_counter*tick_length<adjust_start_time+1000) {  // For [1] second(s) after starting:
//      drive_motor(left_motor, 100, true);                       // Turn clockwise slowly
//      drive_motor(right_motor, 100, false);
//    }
//    else if (not dummy_located) {                                // After the first sweep, start sweeping for dummy slowly and only in the small angle range
//      point_towards_nearest_dummy(1000, 0.95, 100);              // [2] second(s), High threshold, slowly
//    }
//    else if (dummy_located) {                                    // After finding dummy again...
//      if (US_amplitude > home_final_distance) {                  // ...drive until at final distance and stop
//        drive_motor(left_motor, 150, false);
//        drive_motor(right_motor, 150, false);
//      }
//      else {
//        drive_motor(left_motor, 0, false);
//        drive_motor(right_motor, 0 , false);
//        return true;
//      }
//    }
//  } 
//  return false;
//}

bool home_dummy() {

  US_amplitude = take_ultrasonic_reading();

  if (US_amplitude < stopping_distance) {
    proximity_counter2++;
  }
  else {
    proximity_counter2 = 0;
  }
  if (proximity_counter2 > 5) {
    return true;
  }
  else {
    if (home_sweep_time == 0) {
      home_sweep_time = tick_counter*tick_length;
    }
    else if (tick_counter*tick_length < home_sweep_time + creep_time) {
      drive_motor(left_motor,255,false);
      drive_motor(right_motor,255,false);
    }
    else if (tick_counter*tick_length < home_sweep_time + creep_time + 1000) {
      drive_motor(left_motor,255,false);
      drive_motor(right_motor,255,true);
    }
    else {
      dummy_located = false;
      if (point_towards_nearest_dummy(2000,0.95,255)) {
        home_sweep_time = 0;
      }
    }
  }
  return false;
  
}

bool turn(int angle, bool clockwise = true) {                    // Turns a set angle. Should be accurate since uses carefully calibrated motor speed + turn time. Returns true when done
  Serial.print("In turn");
  if (turn_timer == 0) {                                         // If haven't started turning yet
    Serial.println("turn timer = 0");
    Serial.println((angle/360)*full_360_time);
    turn_timer = tick_counter*tick_length;                       // Set current time to turn start time
    
  }
  else if (tick_counter*tick_length < turn_timer + (angle/360.0)*full_360_time) {
    drive_motor(left_motor, motor_360_speed, not clockwise);     // Drive for the correct proportion of a 360 turn at the calibrated speed
    drive_motor(right_motor, motor_360_speed, clockwise);
    Serial.println("motors");
    return false;                                                // Not done yet so return false
  }
  else {
    Serial.println("else we are here");
    drive_motor(left_motor, 0, false);                           // Stop motors
    drive_motor(right_motor, 0, false);
    turn_timer = 0;
    return true;                                                 // Done so return true
  }
}

bool turn_onto_line(){
  read_line_sensors();
  if (line_1){                                                   // If left line sensor on turn to left just as shorter
    drive_motor(right_motor, 255, false);
    drive_motor(left_motor, 255, true);
    return false;
  }
  else if (line_3){                                              // If right line sensor on turn right
    drive_motor(right_motor, 255, true);
    drive_motor(left_motor, 255, false);
    return false;
  }
  else if (not line_2){                                          // Drive forward which gets you back onto line           
    drive_motor(right_motor, 255, false);
    drive_motor(left_motor, 255, false);
    return false;
  }
  else if ((line_2) and (not line_1) and (not line_3)){          // if this doesn't work, remember which you hit first and wait till we hit the other one
    drive_motor(right_motor, 0, false);
    drive_motor(left_motor, 0, false);
    return true;
  }
  else{
    return false;
  }
}

int identify_dummy(){                                            // Reads IR input signal and determines which dummy is in front of it 
                                                                 // Function to return modulation type as enumerated integer (1=mod, 2=mix, 3=unmod, 4=bad)
  
  // Number of times to sample the IR reading (1 sample ~=~ 3.42us)
  int samples = 3509;                                            // Changing this will change the boundary conditions! (averages get skewed!)
  float lower_mod = 0.85;                                        // Lower boundary of average value for modulated signal
  float lower_mix = 0.91;                                        // Lower boundary of average value for mixmodulated signal (and upper for modulated)
  float lower_unm = 0.96;                                        // Lower boundary of average value for unmodulated signal (and upper for mixmodulated)
  
  int sum = 0;
  for (int i = 0; i < samples; i++) {
    sum = sum + (int) digitalRead(IR_MOD_PIN);                   // Continually sample value of wave, and add up total
  }
  float total = (float(sum)/float(samples));                     // Calculate mean value of wave
  
  //Serial.print(total);
  //Serial.print(" ");
  if (total >= lower_mod and total < lower_mix) {
    digitalWrite(LED2_PIN,HIGH);
    digitalWrite(LED3_PIN,HIGH);
    return 1;                                                    // Modulated, white box
  } 
  else if (total >= lower_mix and total < lower_unm) {
    digitalWrite(LED2_PIN,HIGH);
    digitalWrite(LED3_PIN,LOW);
    return 2;                                                    // Mixmodulated, blue box (left hand turn)
  }
  else if (total >= lower_unm) {
    digitalWrite(LED2_PIN,LOW);
    digitalWrite(LED3_PIN,HIGH);
    return 3;                                                    // Unmodulated, red box (right hand turn)
  }
  else {
    digitalWrite(LED2_PIN,LOW);
    digitalWrite(LED3_PIN,LOW);
    return 0;                                                    // Something weird???
  }
}

bool pick_up_dummy(){                                            // Drive servos to pick up dummy. Return true when finished
  if (pick_up_dummy_start_time == 0) {
    pick_up_dummy_start_time = tick_counter*tick_length;         // Initialise
  }
  else if (tick_counter*tick_length < pick_up_dummy_start_time + 1000) {
    claw_servo.write(75);
    lift_servo.write(120);
  }
  else if (tick_counter*tick_length < pick_up_dummy_start_time + 2000) {
    claw_servo.write(75);
    lift_servo.write(70);
  }
  else {
    pick_up_dummy_start_time = 0;
    return true; 
  }
  return false;
}

bool drop_off_dummy(){                                           // Drive servos to released dummy. Return true when finished
  if (drop_off_dummy_start_time == 0) {
    drop_off_dummy_start_time = tick_counter*tick_length;        // Initialise
    claw_servo.write(75);
    lift_servo.write(70);
  }
  else if (tick_counter*tick_length < drop_off_dummy_start_time + 1000) {
    claw_servo.write(75);
    lift_servo.write(120);
  }
  else if (tick_counter*tick_length < drop_off_dummy_start_time + 2000) {
    claw_servo.write(20);
    lift_servo.write(120);
    drop_off_dummy_start_time = 0;
    return true;
  }
  return false;
}


// --------- Setup Function ---------                            // --------- Setup Function ---------
void setup() {                                                   // Function that runs on power-up/RESET
  Serial.begin(9600);                                            // Start Serial to print debug info

  while (!AFMS.begin()) {                                        // Wait until motorshield successfully initialised
    Serial.println("Failed to find motorshield.");
    delay(1000);                 
  }
  Serial.print("Motorshield successfully initialised.");         // Infamous message that will haunt your nightmares (displays repeatedly if Arduino crashing (check drive_motor() uses!))

  pinMode(LED1_PIN, OUTPUT);                                     // Declare the Pin used for Orange LED (LED1) as OUTPUT
  pinMode(LED2_PIN, OUTPUT);
  pinMode(LED3_PIN, OUTPUT);
  pinMode(LS1_PIN, INPUT);                                       // Declare the line sensor pins as inputs
  pinMode(LS2_PIN, INPUT);
  pinMode(LS3_PIN, INPUT);

  pinMode(TRIG_PIN, OUTPUT);                                     // Use TRIG pin as output for ultrasonic sensor (this pin gives an ultrasonic pulse)
  pinMode(ECHO_PIN, INPUT);                                      // Use ECHO pin as input for ultrasonic sensor (this pin reads the echoed ultrasonic pulse from the TRIG pin)
  pinMode(IR_AMP_PIN,INPUT);                                     // Pin for measuring the amplitude of the IR sensor for use in locating dummies
  pinMode(IR_MOD_PIN, INPUT);                                    // Pin for measuring modulated signal to detect dummies
  pinMode(BUTTON_PIN, INPUT);
  pinMode(SERVO_1_PIN, OUTPUT);
  pinMode(SERVO_2_PIN, OUTPUT);
  
  robot_state = 0;                                               // Reset robot state to default

  left_motor->setSpeed(0);                                       // Initialise left motor
  left_motor->run(FORWARD);
  left_motor->run(RELEASE); 

  right_motor->setSpeed(0);                                      // Initialise right motor
  right_motor->run(FORWARD);
  right_motor->run(RELEASE); 

  claw_servo.attach(SERVO_1_PIN);
  lift_servo.attach(SERVO_2_PIN);

  claw_servo.write(20);
  lift_servo.write(120);
}

// --------- Main Loop ---------                                 // --------- Main Loop ---------
void loop() {                                                    // Function that runs repeatedly whilst the robot is on

  if (digitalRead(BUTTON_PIN) == 1) {                            // If button pressed to start the program
    program_started = true;                                      // Start program
  }
  
  if (program_started) {
    if (not using_servos) {
      claw_servo.write(20);
      lift_servo.write(120);
    }
    if (robot_test_state == -1) {                                // Test -1: Display all sensor/input values
      Serial.print("IR Amp: ");
      Serial.print(measure_IR_amplitude(107));                   // IR Amplitude
      Serial.print(" / 1023, US Dist: ");
      Serial.print(take_ultrasonic_reading());                   // Ultrasonic distance
      read_line_sensors();                                       // Update line sensors
      Serial.print(" cm, LS1: ");
      Serial.print(line_1);                                      // Print each line sensor boolean (true = on line, false = off line)
      Serial.print(",");
      Serial.print(analogRead(LS1_PIN));
      Serial.print(", LS2: ");
      Serial.print(line_2);
      Serial.print(",");
      Serial.print(analogRead(LS2_PIN));
      Serial.print(", LS3: ");
      Serial.print(line_3);
      Serial.print(",");
      Serial.print(analogRead(LS3_PIN));
      Serial.print(", IR MOD: ");
      Serial.println(identify_dummy());
    }
    else if (robot_test_state == 1) {                            // Test 1: Spin the wheels without control of any kind
      if (tick_counter*tick_length > 3000) {                     // Wait [3] seconds before beginning test
        drive_motor(left_motor,255,false);                       // Use the electrical function to spin each motor at max speed
        drive_motor(right_motor,255,false);
      }
    }
    else if (robot_test_state == 2 or robot_test_state == 3) {   // Test 2/3: Drive forwards for a fixed time (to give ~1m forwards)
      if (tick_counter*tick_length > 7000) {                     // Drive for [4] seconds
        drive_motor(left_motor,0,false);                         // Stop motors after test complete
        drive_motor(right_motor,0,false);
      }
      else if (tick_counter*tick_length > 3000) {                // Wait [3] seconds before beginning test
        drive_motor(left_motor,255,false);                       // Drive both motors forwards at full speed
        drive_motor(right_motor,255,false);
      }
    }
    else if (robot_test_state == 4) {                            // Test 4: 360 turn in each direction, then reverse for ~1m
      if (tick_counter*tick_length > 13000) {                    // Stop motors after test complete
        drive_motor(left_motor,0,true);                                    
        drive_motor(right_motor,0,true);
      }
      else if (tick_counter*tick_length > 9000) {                // Reverse for [4] seconds = ~1m
        drive_motor(left_motor,255,true);                                    
        drive_motor(right_motor,255,true);
      }
      else if (tick_counter*tick_length > 6000) {                // Spin Counter-clockwise, slowing down to 0 at the end of the 3-second turn
        drive_motor(left_motor,255-255*(tick_counter*tick_length-6000)/3000,true);                                  
        drive_motor(right_motor,255-255*(tick_counter*tick_length-6000)/3000,false);
      }
      else if (tick_counter*tick_length > 3000) {                // Wait [3] seconds before beginning test
                                                                 // Spin Clockwise, slowing down to 0 at the end of the 3-second turn
        drive_motor(left_motor,255-255*(tick_counter*tick_length-3000)/3000,false);                                  
        drive_motor(right_motor,255-255*(tick_counter*tick_length-3000)/3000,true);
      }
    }
    else if (robot_test_state == 5) {                            // Test 5: Crash into dummy. Point at nearest dummy using IR and drive forwards. don't. stop.
      if (tick_counter*tick_length > 3000) {
        if (not temp_test_var1) {                                 // Use point_towards_nearest_dummy until dummy_located
          temp_test_var1 = point_towards_nearest_dummy(2000,0.95,255);
        }
        else {
          drive_motor(left_motor,255,false);                     // Drive!
          drive_motor(right_motor,255,false);
        }
      }
    }
    else if (robot_test_state == 9) {                            // Test 9: Use claw to grab, lift, drive, lower, release, reverse
  
      if (tick_counter*tick_length < 3000) {                     // Default state
        claw_servo.write(20);
        lift_servo.write(120);
      }
      else if (tick_counter*tick_length < 4000) {                // Grab
        claw_servo.write(60);
        lift_servo.write(120);
      }
      else if (tick_counter*tick_length < 5000) {                // Lift
        claw_servo.write(60);
        lift_servo.write(70);
      }
      else if (tick_counter*tick_length < 17000) {               // Drive
        claw_servo.write(60);
        lift_servo.write(70);
        drive_motor(right_motor,255,false);
        drive_motor(left_motor,255,false);
      }
      else if (tick_counter*tick_length < 18000) {               // Stop
        claw_servo.write(60);
        lift_servo.write(70);
        drive_motor(right_motor,0,false);
        drive_motor(left_motor,0,false);
      }
      else if (tick_counter*tick_length < 18500) {               // Lower
        claw_servo.write(60);
        lift_servo.write(115);
      }
      else if (tick_counter*tick_length < 19000) {               // Release
        claw_servo.write(20);
        lift_servo.write(120);
      }
      else if (tick_counter*tick_length < 21000) {               // Return to normal state
        claw_servo.write(20);
        lift_servo.write(120);
      }
      else if (tick_counter*tick_length < 22000) {               // Reverse away
        claw_servo.write(20);
        lift_servo.write(120);
        drive_motor(right_motor,255,true);
        drive_motor(left_motor,255,true);
      }
      else if (tick_counter*tick_length < 23000) {               // Stop
        claw_servo.write(20);
        lift_servo.write(120);
        drive_motor(right_motor,0,true);
        drive_motor(left_motor,0,true);
      }
    }
    
    else if (robot_test_state == 12) {                           // Test 12: Follow line
      if (tick_counter*tick_length > 3000) {                     // Wait [3] seconds before beginning test
        follow_line();                                           // Just run the follow_line() function (forwards)
      }
    }
    else if (robot_test_state == 13) {                           // Test 13: Drive until obstacle is 20cm away, then stop. Then turn until there is nothing for 100cm, then continue drive
      bool temp_test_var = false;
      if (tick_counter*tick_length > 3000) {                     // Wait [3] seconds before beginning test
        if (not temp_test_var) {                                 // Driving forwards mode
          if (take_ultrasonic_reading() > 20) {                  // If not 20cm away yet
            drive_motor(left_motor,255,false);
            drive_motor(right_motor,255,false);
          }
          else {
            temp_test_var = true;                                // Switch mode
          }
        }
        if (temp_test_var) {                                     // Turning mode
          if (take_ultrasonic_reading() < 100) {                 // If wall still closer than 100cm away
            drive_motor(left_motor,255,false);
            drive_motor(right_motor,255,true);
          }
          else {
            temp_test_var = false;                               // Switch mode
          }
        }
      }
    }
    else if (robot_test_state == 14) {                           // Test 14: Locate and home dummy, then grab it.
      if (tick_counter*tick_length > 3000) {                     // Wait 3 seconds
        if (not temp_test_var3 and temp_test_var2 == 0) {
          temp_test_var3 = point_towards_nearest_dummy(10000,0.8,255);            // Point towards dummy, use standard settings
          using_servos = false;
        }
        else {
          temp_test_var2 = 1;                                    // Located!
        }
        if (temp_test_var2 == 1) {                               // Home_dummy until stopped right in front of it
          if (home_dummy()) {
            temp_test_var2 = 2;                                  // Switch mode again
            using_servos = false;
          }
        }
        if (temp_test_var2 == 2) {                               // Use claw to grab dummy
          using_servos = false;
          drive_motor(left_motor,0,false);
          drive_motor(right_motor,0,false);
        }
      }
    }
    else if (robot_test_state == 15) {                           // Test 15: Identify dummy. Whilst in front of dummy, blink the correct LEDs to show which dummy this one is       
      if (tick_counter*tick_length > 3000) {                     // Wait 3 seconds
        identify_dummy();                                        // Identify dummy testing
      }
    }
    else if (robot_test_state == 17) {                           // Test 17: Turn 180 degrees then stop and turn the red LED on
      if (tick_counter*tick_length > 500) {                      // Wait 0.5 seconds
        if (not temp_test_var4) {                                // If not stopped yet
          temp_test_var4 = turn(180,false);                      // Turn
        }
        else {
          digitalWrite(LED3_PIN,HIGH);                           // Turn red LED on
        }
      }
    }
    else if (robot_test_state == 21) {                           // this corresponds to robot state 0 of main code
      if (take_ultrasonic_reading() > 5){                        // this should drive us up over the ramp to the first dummy no idea what the ir value should be right now
        follow_line();
      }
      else {
        drive_motor(left_motor,0,false);                                    
        drive_motor(right_motor,0,false);
        if (delay_5s_start_time == 0){
          delay_5s_start_time = tick_counter*tick_length;
        }
        if (((tick_counter * tick_counter) > (0+delay_5s_start_time)) and ((tick_counter * tick_length) < (delay_5s_start_time + 5000))){
          what_dummy_am_I = identify_dummy();
        }
        if ((tick_length * tick_counter) > (delay_5s_start_time + 5000)){
          picked_up_yet = pick_up_dummy();
        }
        if (picked_up_yet){
          delay_5s_start_time = 0;
          robot_state = 1;
          picked_up_yet = false;
        }
      }
    }
    else if (robot_test_state == 22) {                           // Test 22: Test used to calibrate turning. Turns 2 full turns
      if (not temp_test_var5) {
        temp_test_var5 = turn(720);
      }
    }
    else if (robot_test_state == 23) {                           // Test 23: Accurate turning demo
      if (tick_counter*tick_length < 3000) {
        temp_test_var6 = 0;
      }
      else {
        if (temp_test_var6 == 0) {
          if (turn(360,false)) {
            temp_test_var6 = 1;
          }
        }
        else if (temp_test_var6 == 1) {
          if (turn(360,true)) {
            temp_test_var6 = 2;
          }
        }
        else if (temp_test_var6 == 2) {
          if (turn(90,false)) {
            temp_test_var6 = 3;
          }
        }
        else if (temp_test_var6 == 3) {
          if (turn(90,true)) {
            temp_test_var6 = 4;
          }
        }
        else if (temp_test_var6 == 4) {
          digitalWrite(LED3_PIN,HIGH);
        }
      }
    }
    else if (robot_test_state == 24) {
      using_servos = false;
      if (home_dummy()) {
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
        delay(100000);
      }
    }
    else if (robot_test_state == 25) {
      using_servos = true;
      if (not temp_test_var7) {
        temp_test_var7 = pick_up_dummy();
      }
      else if (drop_off_dummy()){
        
        
      }
    }
    else if (robot_test_state == 100) {                      // Tests 100+: Running parts of the main code. The program sets all the correct state variables and leaves the testing state to run the main code                          
      if (tick_counter*tick_length < 3000) {
        if (tick_counter*tick_length % 500 < 250) {
          digitalWrite(LED3_PIN,HIGH);
        }
        else {
          digitalWrite(LED3_PIN,LOW);
        }

        robot_state = 0;
        
      }
      else if (not main_test_started and robot_state == 0) {
        digitalWrite(LED3_PIN,LOW);
        main_test_started = true;
      }
      else if (robot_state != 0) {
        main_test_started = false;
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
        digitalWrite(LED3_PIN,HIGH);
      }
    }
    else if (robot_test_state == 110) {                      // Tests 100+: Running parts of the main code. The program sets all the correct state variables and leaves the testing state to run the main code                          
      if (tick_counter*tick_length < 3000) {
        if (tick_counter*tick_length % 500 < 250) {
          digitalWrite(LED3_PIN,HIGH);
        }
        else {
          digitalWrite(LED3_PIN,LOW);
        }

        robot_state = 1;
        what_dummy_am_I = 1;
        robot_sub_state = 0;
        
      }
      else if (not main_test_started and robot_state == 1) {
        digitalWrite(LED3_PIN,LOW);
        main_test_started = true;
      }
      else if (robot_state != 0) {
        main_test_started = false;
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
      }
    }
    else if (robot_test_state == 111) {                      // Tests 100+: Running parts of the main code. The program sets all the correct state variables and leaves the testing state to run the main code                          
      if (tick_counter*tick_length < 3000) {
        if (tick_counter*tick_length % 500 < 250) {
          digitalWrite(LED3_PIN,HIGH);
        }
        else {
          digitalWrite(LED3_PIN,LOW);
        }

        robot_state = 1;
        what_dummy_am_I = 2;
        robot_sub_state = 0;
        number_dummies_saved = 0;
        
      }
      else if (not main_test_started and robot_state == 1) {
        digitalWrite(LED3_PIN,LOW);
        main_test_started = true;
      }
      else if (robot_sub_state > 3) {
        main_test_started = false;
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
      }
    }
    else if (robot_test_state == 112) {                      // Tests 100+: Running parts of the main code. The program sets all the correct state variables and leaves the testing state to run the main code                          
      if (tick_counter*tick_length < 3000) {
        if (tick_counter*tick_length % 500 < 250) {
          digitalWrite(LED3_PIN,HIGH);
        }
        else {
          digitalWrite(LED3_PIN,LOW);
        }

        robot_state = 1;
        what_dummy_am_I = 2;
        robot_sub_state = 4;
        number_dummies_saved = 0;
        
      }
      else if (not main_test_started and robot_state == 1) {
        digitalWrite(LED3_PIN,LOW);
        main_test_started = true;
      }
      else if (robot_state != 1) {
        main_test_started = false;
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
      }
    }
    else if (robot_test_state == 120) {                      // Tests 100+: Running parts of the main code. The program sets all the correct state variables and leaves the testing state to run the main code                          
      if (tick_counter*tick_length < 3000) {
        if (tick_counter*tick_length % 500 < 250) {
          digitalWrite(LED3_PIN,HIGH);
        }
        else {
          digitalWrite(LED3_PIN,LOW);
        }

        robot_state = 2;
        robot_sub_state = 0;
        number_dummies_saved = 1;
        
      }
      else if (not main_test_started and robot_state == 2) {
        digitalWrite(LED3_PIN,LOW);
        main_test_started = true;
      }
      else if (robot_state != 2) {
        main_test_started = false;
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
      }
    }
    else if (robot_test_state == 130) {                      // Tests 100+: Running parts of the main code. The program sets all the correct state variables and leaves the testing state to run the main code                          
      if (tick_counter*tick_length < 3000) {
        if (tick_counter*tick_length % 500 < 250) {
          digitalWrite(LED3_PIN,HIGH);
        }
        else {
          digitalWrite(LED3_PIN,LOW);
        }

        robot_state = 3;
        robot_sub_state = 0;
        number_dummies_saved = 1;
        
      }
      else if (not main_test_started and robot_state == 3) {
        digitalWrite(LED3_PIN,LOW);
        main_test_started = true;
      }
      else if (robot_state != 3) {
        main_test_started = false;
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
      }
    }
    else if (robot_test_state == 140) {                      // Tests 100+: Running parts of the main code. The program sets all the correct state variables and leaves the testing state to run the main code                          
      if (tick_counter*tick_length < 3000) {
        if (tick_counter*tick_length % 500 < 250) {
          digitalWrite(LED3_PIN,HIGH);
        }
        else {
          digitalWrite(LED3_PIN,LOW);
        }

        robot_state = 4;
        robot_sub_state = 0;
        number_dummies_saved = 3;
        
      }
      else if (not main_test_started and robot_state == 4) {
        digitalWrite(LED3_PIN,LOW);
        main_test_started = true;
      }
      else if (robot_state != 4) {
        main_test_started = false;
        drive_motor(left_motor,0,false);
        drive_motor(right_motor,0,false);
      }
    }
      

// ------------------------------------------------------------ MAIN PROGRAM ------------------------------------------------------------
    if (robot_test_state == 0 or (robot_test_state >= 100 and main_test_started)) {
      if (robot_state == 0) {
        int temp_ultrasonic = 0;
        temp_ultrasonic = take_ultrasonic_reading();
        if (temp_ultrasonic > stopping_distance){                                // this should drive us up over the ramp to the first dummy no idea what the ir value should be right now
          follow_line();
          proximity_counter = 0;
          digitalWrite(LED2_PIN,LOW);
          digitalWrite(LED3_PIN,LOW);
        }
        else{
          proximity_counter ++;
        }
        if (proximity_counter > counter_cutoff) {
          drive_motor(left_motor,0,false);                                    
          drive_motor(right_motor,0,false);
          if (delay_5s_start_time == 0){
            delay_5s_start_time = tick_counter*tick_length;
            using_servos = false;
          }
          if (((tick_counter * tick_counter) > (-1+delay_5s_start_time)) and ((tick_counter * tick_length) < (delay_5s_start_time + 1600))){
            what_dummy_am_I = identify_dummy();
            Serial.println("what dummy in state 0: ");
            Serial.print(what_dummy_am_I);
            using_servos = false;
          }
          if ((tick_length * tick_counter) > (delay_5s_start_time + 1599) and not picked_up_yet){
            using_servos = true;
            picked_up_yet = pick_up_dummy();
            Serial.println("picking up");
          }
          if (picked_up_yet){
            Serial.println("now we have picked up");
            delay_5s_start_time = 0;
            robot_state = 1;
            picked_up_yet = false;
            drive_motor(left_motor,0,false);
            drive_motor(right_motor,0,false);
          }
        }
      }

      if ((what_dummy_am_I == 1) and robot_state == 1){          // modulated dummy going to white box from on line position, at the end of this IF statement the robot is on line facing dummy in white box
        Serial.println(what_dummy_am_I);
        if (robot_sub_state == 0){
          if (follow_line()){                                //test state 1 is having just picked up dummy
            finished_dropping = drop_off_dummy();
            drive_motor(right_motor,0,false);
            drive_motor(left_motor,0,false);
            using_servos = true;
          }
          if (finished_dropping){
            number_dummies_saved += 1;
            robot_sub_state = 1;
            using_servos = false;
          }
        }
        if (robot_sub_state == 1){
          if (reverse_3s == 0){
            reverse_3s = tick_counter * tick_length;
          }                                                  //reverse for 2s
          else if (tick_counter * tick_length < reverse_3s + 2000){
            drive_motor(left_motor,255,true);
            drive_motor(right_motor,255,true);
          }
          else{
            robot_state = 2;
            robot_sub_state = 0;
            reverse_3s = 0;
            finished_dropping = false;
            drive_motor(left_motor,0,false);
            drive_motor(right_motor,0,false);
          }
        }
      }
      if ((what_dummy_am_I == 2 or what_dummy_am_I == 3) and (robot_state == 1)){
        Serial.println(what_dummy_am_I);
        // delivers first dummy that's on the line to the RED box  modulated ir signal, starts with dummy in grasp

        if (robot_sub_state == 0){                               // turns to face home
          if (turn(180)){
            robot_sub_state = 1;
          }
        }
        if (robot_sub_state == 1){
          if (follow_line()){                                    //drive back to start untill encounter cross roads
            robot_sub_state = 2;
          }
        }
        if (robot_sub_state == 2){
          if (drive_1s_timer == 0){
            drive_1s_timer = tick_counter * tick_length; 
          } 
        //drive 1s forward after first finding line so that when it turns 90 it will drop into box
          else if (tick_length * tick_counter < drive_1s_timer + 1000){
            follow_line();
          }
          else{
            drive_motor(left_motor, 0, false);
            drive_motor(left_motor, 0, false);
            robot_sub_state = 3;
          }
           
        }
        if (robot_sub_state == 3){
          if (what_dummy_am_I == 2){
            if(turn(90, true)){                                  //turn 90 clockwise
              robot_sub_state = 4;
            }
          }
          else{
            if(turn(90, false)){                                  //turn 90 anticlockwise
              robot_sub_state = 4;
            }
          }
        }
        if (robot_sub_state == 4){
          finished_dropping = drop_off_dummy();
          if (finished_dropping){                            //drops off red box dummy
            number_dummies_saved += 1;
            robot_sub_state = 5;
           }
         }
         
        if (robot_sub_state == 5){
          if (reverse_touch == 0){
            reverse_touch = tick_counter * tick_length;
          }                                                  //reverse for 2s
          else if (tick_counter * tick_length < reverse_touch + 500){
            drive_motor(left_motor,255,true);
            drive_motor(right_motor,255,true);
          }
          else{
            robot_sub_state = 7;
          }
        }

        if (robot_sub_state == 7){                               // turns the robot back onto line facing danger area
          if (what_dummy_am_I == 2){
            if(turn(90, true)){
              robot_sub_state = 8;
            }
          }
          else {
            if(turn(90, false)){
              robot_sub_state = 8;
            }
          }
        }

        if (robot_sub_state == 8){
          int temp_ultrasonic = 0;
          temp_ultrasonic = take_ultrasonic_reading();
          if (temp_ultrasonic > 50){                             // this should drive us up over the ramp and stop 50cm from end so we can sweep for dummies again.
                                                                 // requires 3 US values under 50cm in a row to activate to avoid any random disturbance
            follow_line();
            proximity_counter_2 = 0;
          }
          else{
            proximity_counter_2 ++;
          }
          if (proximity_counter_2 > counter_cutoff) {
            drive_motor(left_motor,0,false);
            drive_motor(right_motor,0,false);
            robot_sub_state = 0;
            robot_state = 2;
            what_dummy_am_I = 0;
          }
        }


        // else if (hit_cross_roads == 2){
        //   if (drive_1s_timer = 0){
        //     drive_1s_timer = tick_counter * tick_length; 
        //   }                                                      //drive 1s forward into box from top of box
        //   else if (tick_length * tick_counter < drive_1s_timer + 1000){
        //     drive_motor(left_motor, 255, true);
        //     drive_motor(right_motor, 255, true);
        //   }
        //   else{                                                  //stop
        //     drive_motor(left_motor, 0, true);
        //     drive_motor(right_motor, 0, true);
        //   }
        // }
      }
      
      if (robot_state == 2){                                     // finds the dummy. Starts on the line (advanced area)
        if (number_dummies_saved == 3){
          robot_state = 4;
        }
        if (robot_sub_state == 0){
          if (not dummy_located){
            point_towards_nearest_dummy();
            if (dummy_located) {
              robot_sub_state = 1;
            }
          }
        }
        if (robot_sub_state == 1) {
          if (home_dummy()) {
            robot_sub_state = 2;
          }
        }
        if(robot_sub_state == 2){
          if (delay_5s_start_time == 0){
            delay_5s_start_time = tick_counter*tick_length;
          }
          if (((tick_counter * tick_counter) > (0+delay_5s_start_time)) and ((tick_counter * tick_length) < (delay_5s_start_time + 5000))){
            what_dummy_am_I = identify_dummy();
          }
          if ((tick_length * tick_counter) > (delay_5s_start_time + 5000)){
            picked_up_yet = pick_up_dummy();
          }
          if (picked_up_yet){                                    // identifies the dummy waits 5s and picks it up
            delay_5s_start_time = 0;
            robot_state = 3;
            robot_sub_state = 0;
            picked_up_yet = false;
            dummy_located = false;
          }
        }
      }

      if (robot_state == 3){                                     //found second dummy, need to return it to its home, goes back to prime posiiton with dummy in arms
        if (robot_sub_state == 0){
          if ((not line_1) and (not line_2) and (not line_3) and (picked_up_yet)){      // back up untill we hit line
            drive_motor(left_motor,255,true);
            drive_motor(right_motor,255,true);
          }
          // spin untill on line facing either way, if ultrasound < 1m do a U turn, if >1m go straight on, need to do spin 180 code and from the reverse position spin and go forward. also follow line revers
          else if(turn_onto_line()){
            robot_sub_state = 1;
            finished_dropping = false;
          }
        }
        if (robot_sub_state == 1){
        // if its the white box dummy, check which way we're facing and then re-use same code as it you've just picked it up when it was already on the line
          if (take_ultrasonic_reading() < 100){
            robot_state = 1;
            robot_sub_state =0;
          }
          else {
            if (turn(180)){
              robot_state = 1;
              robot_sub_state =0;
            }
          }
        }
      }
      if (robot_state == 4){                                     // this is the go home part of the algorithm
        if (robot_sub_state == 0){                               // turns around so facing home
          if (turn(180)){
            robot_sub_state =1;
          }
        }
        if (robot_sub_state == 1){
          if (follow_line() and hit_cross_roads == 2){
            if (drive_1s_2 == 0){
              drive_1s_2 = tick_counter * tick_length; 
            } 
          //drive 1s forward after first finding line so that when it turns 90 it will drop into box
            else if (tick_length * tick_counter < drive_1s_2 + 1000){
              drive_motor(left_motor,255,false);
              drive_motor(right_motor,255,false);
            }
            else{
              drive_motor(left_motor,0,false);
              drive_motor(right_motor,0,false);
              robot_state = 5;
              robot_sub_state = 0;
            }
          }
          if (follow_line()){
            hit_cross_roads = 1;                                 // hit first cross roads but want to continue
          }
          if (hit_cross_roads == 1){
            if (not follow_line()){                              // once it goes of the back of the line
              hit_cross_roads == 2;
            }
          }
        }
      }
//
//      // if ((robot_test_state == 6) and (robot_state == 3)){    //first competetion breakaway point RESUME FROM HERE not useable but some may be copy and pastable
//      //   if ((not turn(180)) and (not turned_yet)){
//      //   }
//      //   else{
//      //     turned_yet = true;
//      //     robot_state = 3.1;
//      //   }
//  
//      // if ((robot_test_state == 6) and (robot_state == 3.1))        //succesfully turned 180 to face back to start (still competition breakaway)
//      //   if (follow_line()){                                        //drive back to start then count when over first cross roads
//      //     hit_cross_roads += 1;
//      //   }                                                          // will return true more than once ! only add it when line sensors gone off again!!
//      //   else if (hit_cross_roads == 2){
//      //     if (drive_1s_timer = 0){
//      //       drive_1s_timer = tick_counter * tick_length; 
//      //     }                                                        //drive 1s forward into box from top of box
//      //     else if (tick_length * tick_counter < drive_1s_timer + 1000){
//      //       drive_motor(left_motor, 255, true);
//      //       drive_motor(right_motor, 255, true);
//      //     }
//      //     else{                                                    //stop
//      //       drive_motor(left_motor, 0, true);
//      //       drive_motor(right_motor, 0, true);
//      //     }
//      //   }
//      // }
//  
// 
    }
    tick_counter ++;                                             // Increment tick counter
    delay(tick_length - (millis() % tick_length));               // Delay the remaining milliseconds of the tick to keep tick rate constant (as long as computer fast enough)
  }
}
